//working shader

#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_gpu_shader_int64 : enable

#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1 ) in;
// 3.14159265358979323846264338327950
const double PI = 3.14159265358979323846264338327950;
const uint64_t rngKey = (0xc8e4fd15 << 32) | 0x4ce32f6d;
const double inm2eV = 1.239852e3;

/* STRUCTS */

struct Ray{
	dvec3 position;
	double weight; // status of the ray (e.g if element missed -> 0)
	dvec3 direction;
	double energy;
	dvec4 stokes;
	double pathLength;
	double order;
	double lastElement;
	double extraParameter;
};
struct Element{
	dmat4 surfaceParams;
	dmat4 inTrans;
	dmat4 outTrans;
	dmat4 objectParameters;
	dmat4 elementParameters;
};
layout(std140, binding = 0) buffer ibuf
{
   Ray rayData[];
};

layout(std140, binding = 1) buffer obuf
{
   Ray outputData[];
};
layout(std140, binding = 2) buffer qbuf
{
	double numberOfBeamlines;
	double numberOfElementsPerBeamline;
	double numberOfRays;
	double numberOfRaysPerBeamLine;
	Element quadricData[];
};
layout(std140, binding = 3) buffer xyzbuf
{
	dvec4 xyznull[];
};

#include "shader/setup.comp"

/* HERE STARTS RAY TRACING CODE */

double hvlam(double x) {
    if(x==0) {
        return 0.0;
    }
    return inm2eV / x;
}

// multiplies position and direction of ray r with transformation matrix m
// r = dot(m, r)
Ray rayMatrixMult(Ray r, const dmat4 m) {
	r.position = dvec3(m * dvec4(r.position,1));
	r.direction = dvec3(m * dvec4(r.direction,0));
	return r;
}

Ray rotationAroundX(Ray r, double sin_psi, double cos_psi) {
	dmat4 rotation_matrix = dmat4(1, 0, 0, 0,
				0, cos_psi, -sin_psi, 0,
				0, sin_psi, cos_psi, 0,
				0,0,0,1);
	return rayMatrixMult(r, rotation_matrix);
}

/**
* uses given transformation matrix to transform ray position and direction into Object coordinates
* also takes misalignment of the object into account
* @param r				input ray in Ray-coordinates
* @param misalignment	4x4 homogeneous matrix that contains the misalignment of the element (dx, dy, dz, dphi, dpsi, dchi)
* @param inTrans		4x4 homogeneous matrix that contains the transformation of ray-coordinates to object coordinates (distance to previous element, grazing incidence angle, azimuthal angle)
*
* output: nothing. changes r in place
*/
void inTransformation(inout Ray r, const dmat4 misalignment, const dmat4 inTrans) {
	r.position = dvec3(misalignment * (inTrans *  dvec4(r.position,1)) );
	r.direction = dvec3(misalignment * (inTrans * dvec4(r.direction,0)));
}

/**
* uses given transformation matrix to transform ray position and direction back into Ray coordinates
* also takes misalignment of the object into account. Note that the order of the transformations is reversed and we use the inverse of the misalignment matrix
* @param r				input ray in Ray-coordinates
* @param invMisalignment	4x4 homogeneous matrix that contains the misalignment of the element (dx, dy, dz, dphi, dpsi, dchi)
* @param outTrans		3x3 homogeneous matrix (in 4x4 matrix for standardization) that contains the transformation of object coordinates to ray-coordinates (rotations only: grazing exit angle, neg. azimuthal angle)
*
* output: nothing. changes r in place
*/
void outTransformation(inout Ray r, const dmat4 invMisalignment, const dmat4 outTrans) {
	r.position = dvec3(outTrans * (invMisalignment * dvec4(r.position,1)));
	r.direction = dvec3(outTrans * (invMisalignment * dvec4(r.direction,0)));
}


// only for testing purposes. generally, each angle in the shader is in rad!!
double deg2rad(double degree) {
	// double PI = 3.141592653589793238462643383279502884197169399;//3 7 5 1 0 5 8 2 0 9 7 4 9 4 4 5 9
	return PI * degree / 180;
}

// dummy function for univariate random numbers
double[3] random_number(int n) {
	return double[3] (0.5,0.5,0.5);
}

// returns forial of a (from RAYLIB.for) (a!)
double fact(int a) {
	if(a < 0) {
		return a;
	}
	double f = 1;
	for(int i = 2; i<=a; i++) {
		f *= i;
	}
	return f;
}

/**
calculates direction cosini from angles phi,psi given in rad
@params r		ray whose direction vector is recalculated (inout)
		phi		horizontal angle in x-z-plane (pos.rotation, counterclockwise)
		phi		vertical angle in y-z-plane (pos.rotation, counterclockwise)
*/
void cosini(inout Ray r, double phi, double psi) {
	double cos_psi = r8_cos(psi);
	double cos_phi = r8_cos(phi);
	double sin_psi = r8_sin(psi);
	double sin_phi = r8_sin(phi);

	r.direction.x = cos_psi * sin_phi;
	r.direction.y = -sin_psi;
	r.direction.z = cos_psi * cos_phi;
}


/**
* checks whether the intersection point is within the extent of the surface
* @param x, z			 	x- and z-coordinates of the intersection point in element coordinates
* @param xLength, zLength	width and length of the optical element
* @param w 					current weight of the ray
*
* returns: unchanged weight if intersection point is within surface boundaries, 0.0 if not.
*/
double wasteBox(double x, double z, double xLength, double zLength, double w)
{
	if (xLength >= 0) { // Rectangular shape
		double x_min = -xLength/2.0;
		double x_max = xLength/2.0;
		double z_min = -zLength/2.0;
		double z_max = zLength/2.0;
		w *= int(x > x_min) * int(x < x_max) * int(z > z_min) * int(z < z_max); // This sets w to zero, if (x <= x_min || x >= x_max || z <= z_min || z >= z_max)
	} else {	// Ring shape
		double rd2 = (x/(xLength/2.0)) * (x/(xLength/2.0)) + (z/(zLength/2.0)) * (z/(zLength/2.0));
		w *= int(rd2 <= 1.0); // This sets w to zero, if (rd > 1.0)
	}
	return w;
}

// ! temporary for testing purposes (trapezoid)
double wasteBox(double x, double z, double xLengthA, double xLengthB, double zLength, double w)
{
	if (xLengthA >= 0){ // Rectangular shape
		if (xLengthB > 0){ // Trapezoid shape
			// Check point is within the trapezoid
			dvec3 P = dvec3(x,0,z);
			dvec3 A = dvec3(xLengthA/2.0, 0, zLength/2.0);
			dvec3 B = dvec3(-xLengthA/2.0, 0, zLength/2.0);
			dvec3 C = dvec3(xLengthB/2.0, 0, -zLength/2.0);
			dvec3 D = dvec3(-xLengthB/2.0, 0, -zLength/2.0);

			if (dot(cross(P-A, B-A), cross(P-D, C-D)) >= 0 || dot(cross(P-A, B-A), cross(P-D, C-D)) >= 0) {
				return 0.0;
			}
		}
		else {
			double x_min = -xLengthA/2.0;
			double x_max = xLengthA/2.0;
			double z_min = -zLength/2.0;
			double z_max = zLength/2.0;
			
			if (x <= x_min || x >= x_max || z <= z_min || z >= z_max) {
				return 0.0;
			}
		}
	}else{	// Ring shape
		double rd2 = (x/(xLengthA/2.0)) * (x/(xLengthA/2.0)) + (z/(zLength/2.0)) * (z/(zLength/2.0));
		if (rd2 > 1.0) {
			return 0.0;
		}
	}
	return w;
}

/**
* calculates the intersection point of a ray with a quadric surface defined by a_11..a_44
* @param r				ray for which the intersection is fount
* @param a_11..a_44		define the quadric surface
* @param icurv 			defines whether the first or the second intersection is used (1=first, -1=second)
*
* output: reflected Ray with intersection point as position and reflection as direction
*/
dvec4 intersectionPoint(inout Ray r, const dmat4 quadric)
{
	// //for testing
	// double firstParam;
	// double secondParam;

	double a_11 = quadric[0][0];
	double a_12 = quadric[0][1];
	double a_13 = quadric[0][2];
	double a_14 = quadric[0][3];
	double a_22 = quadric[1][1];
	double a_23 = quadric[1][2];
	double a_24 = quadric[1][3];
	double a_33 = quadric[2][2];
	double a_34 = quadric[2][3];
	double a_44 = quadric[3][3];
	int icurv = int(quadric[1][0]);

	double w = r.weight;
	int cs = 1;
	int d_sign = icurv;
	if (abs(r.direction[1]) >= abs(r.direction[0]) && abs(r.direction[1]) >= abs(r.direction[2])) {
		cs = 2;
	}else if (abs(r.direction[2]) >= abs(r.direction[0]) && abs(r.direction[2]) >= abs(r.direction[1])) {
		cs = 3;
	}

	double x;
	double y;
	double z;
	double a = 0;
	double b = 0;
	double c = 0;

	if (cs == 1) {
		double aml = r.direction[1] / r.direction[0];
		double anl = r.direction[2] / r.direction[0];
		y = r.position[1] - aml * r.position[0];
		z = r.position[2] - anl * r.position[0];
		d_sign = int(sign(r.direction[0]) * icurv);

		a = a_11 + 2*a_12*aml + a_22*aml*aml + 2*a_13*anl + 2*a_23*aml*anl + a_33*anl*anl;
        b = a_14 + a_24*aml + a_34*anl + (a_12 + a_22*aml + a_23*anl)*y + (a_13 + a_23*aml + a_33*anl)*z;
        c = a_44 + a_22*y*y + 2*a_34*z + a_33*z*z + 2*y*(a_24 + a_23*z);

		double bbac = b*b - a*c;
		if (bbac < 0) {
			w = 0.0;
			x = - y/aml; 	// x such that y=0
		}else{
			if (abs(a) > abs(c)*1e-10) {
				x = (-b + d_sign*sqrt(bbac)) / a;
			}else{
				x = (-c/2)/b;
			}
		}
		y = y + aml*x;
		z = z + anl*x;
	}else if (cs == 2) {
		double alm = r.direction[0] / r.direction[1];
		double anm = r.direction[2] / r.direction[1];
		x = r.position[0] - alm * r.position[1];
		z = r.position[2] - anm * r.position[1];
		d_sign = int(sign(r.direction[1]) * icurv);

		a = a_22 + 2*a_12*alm + a_11*alm*alm + 2*a_23*anm + 2*a_13*alm*anm + a_33*anm*anm;
        b = a_24 + a_14*alm + a_34*anm + (a_12 + a_11*alm + a_13*anm)*x + (a_23 + a_13*alm + a_33*anm)*z;
        c = a_44 + a_11*x*x + 2*a_34*z + a_33*z*z + 2*x*(a_14 + a_13*z);

		double bbac = b*b - a*c;
		if (bbac < 0) {
			w = 0.0;
			y = 0;
		}else{
			if (abs(a) > abs(c)*1e-10) {
				y = (-b + d_sign*sqrt(bbac)) / a;
			}else{
				y = (-c/2)/b;
			}
		}
		x = x + alm*y;
		z = z + anm*y;

	}else{
		double aln = r.direction[0] / r.direction[2];
		double amn = r.direction[1] / r.direction[2];
		// firstParam = aln;
		// secondParam = amn;
		x = r.position[0] - aln * r.position[2];
		y = r.position[1] - amn * r.position[2];
		d_sign = int(sign(r.direction[2]) * icurv);

		a = a_33 + 2*a_13*aln + a_11*aln*aln + 2*a_23*amn + 2*a_12*aln*amn + a_22*amn*amn;
        b = a_34 + a_14*aln + a_24*amn + (a_13 + a_11*aln + a_12*amn)*x + (a_23 + a_12*aln + a_22*amn)*y;
        c = a_44 + a_11*x*x + 2*a_24*y + a_22*y*y + 2*x*(a_14 + a_12*y);

		double bbac = b*b - a*c;
		if (bbac < 0) {
			w = 0.0;
			z = -y / amn;
		}else{
			if (abs(a) > abs(c)*1e-10) {//pow(10, double(-10))) {
				z = (-b + d_sign*sqrt(bbac)) / a;
			}else{
				z = (-c/2)/b;
			}
		}
		x = x + aln*z;
		y = y + amn*z;
		//r.position = dvec3(a, b, c);
	}

	double fx = 2*a_14 + 2*a_11*x + 2*a_12*y + 2*a_13*z;
	double fy = 2*a_24 + 2*a_12*x + 2*a_22*y + 2*a_23*z;
    double fz = 2*a_34 + 2*a_13*x + 2*a_23*y + 2*a_33*z;

	dvec4 normal = normalize(dvec4(fx,fy,fz,0));
	r.position = dvec3(x,y,z); // new position = intersection point
	r.weight = w; // unchanged, if ray did not miss surface, else 0
	//r.direction = dvec3(firstParam,secondParam,c);
	return normal;
}

dvec4 getIntersectionPoint(Ray r, dmat4 quadric)
{
	// //for testing
	// double firstParam;
	// double secondParam;

	double a_11 = quadric[0][0];
	double a_12 = quadric[0][1];
	double a_13 = quadric[0][2];
	double a_14 = quadric[0][3];
	double a_22 = quadric[1][1];
	double a_23 = quadric[1][2];
	double a_24 = quadric[1][3];
	double a_33 = quadric[2][2];
	double a_34 = quadric[2][3];
	double a_44 = quadric[3][3];
	int icurv = int(quadric[1][0]);

	double w = r.weight;
	int cs = 1;
	int d_sign = icurv;
	if (abs(r.direction[1]) >= abs(r.direction[0]) && abs(r.direction[1]) >= abs(r.direction[2])) {
		cs = 2;
	}else if (abs(r.direction[2]) >= abs(r.direction[0]) && abs(r.direction[2]) >= abs(r.direction[1])) {
		cs = 3;
	}

	double x;
	double y;
	double z;
	double a = 0;
	double b = 0;
	double c = 0;

	if (cs == 1) {
		double aml = r.direction[1] / r.direction[0];
		double anl = r.direction[2] / r.direction[0];
		y = r.position[1] - aml * r.position[0];
		z = r.position[2] - anl * r.position[0];
		d_sign = int(sign(r.direction[0]) * icurv);

		a = a_11 + 2*a_12*aml + a_22*aml*aml + 2*a_13*anl + 2*a_23*aml*anl + a_33*anl*anl;
        b = a_14 + a_24*aml + a_34*anl + (a_12 + a_22*aml + a_23*anl)*y + (a_13 + a_23*aml + a_33*anl)*z;
        c = a_44 + a_22*y*y + 2*a_34*z + a_33*z*z + 2*y*(a_24 + a_23*z);

		double bbac = b*b - a*c;
		if (bbac < 0) {
			w = 0.0;
			x = - y/aml; 	// x such that y=0
		}else{
			if (abs(a) > abs(c)*1e-10) {
				x = (-b + d_sign*sqrt(bbac)) / a;
			}else{
				x = (-c/2)/b;
			}
		}
		y = y + aml*x;
		z = z + anl*x;
	}else if (cs == 2) {
		double alm = r.direction[0] / r.direction[1];
		double anm = r.direction[2] / r.direction[1];
		x = r.position[0] - alm * r.position[1];
		z = r.position[2] - anm * r.position[1];
		d_sign = int(sign(r.direction[1]) * icurv);

		a = a_22 + 2*a_12*alm + a_11*alm*alm + 2*a_23*anm + 2*a_13*alm*anm + a_33*anm*anm;
        b = a_24 + a_14*alm + a_34*anm + (a_12 + a_11*alm + a_13*anm)*x + (a_23 + a_13*alm + a_33*anm)*z;
        c = a_44 + a_11*x*x + 2*a_34*z + a_33*z*z + 2*x*(a_14 + a_13*z);

		double bbac = b*b - a*c;
		if (bbac < 0) {
			w = 0.0;
			y = 0;
		}else{
			if (abs(a) > abs(c)*1e-10) {
				y = (-b + d_sign*sqrt(bbac)) / a;
			}else{
				y = (-c/2)/b;
			}
		}
		x = x + alm*y;
		z = z + anm*y;

	}else{
		double aln = r.direction[0] / r.direction[2];
		double amn = r.direction[1] / r.direction[2];
		// firstParam = aln;
		// secondParam = amn;
		x = r.position[0] - aln * r.position[2];
		y = r.position[1] - amn * r.position[2];
		d_sign = int(sign(r.direction[2]) * icurv);

		a = a_33 + 2*a_13*aln + a_11*aln*aln + 2*a_23*amn + 2*a_12*aln*amn + a_22*amn*amn;
        b = a_34 + a_14*aln + a_24*amn + (a_13 + a_11*aln + a_12*amn)*x + (a_23 + a_12*aln + a_22*amn)*y;
        c = a_44 + a_11*x*x + 2*a_24*y + a_22*y*y + 2*x*(a_14 + a_12*y);

		double bbac = b*b - a*c;
		if (bbac < 0) {
			w = 0.0;
			z = -y / amn;
		}else{
			if (abs(a) > abs(c)*1e-10) {//pow(10, double(-10))) {
				z = (-b + d_sign*sqrt(bbac)) / a;
			}else{
				z = (-c/2)/b;
			}
		}
		x = x + aln*z;
		y = y + amn*z;
		//r.position = dvec3(a, b, c);
	}

	// intersection point is in the negative direction (behind the position when the direction is followed forwards), set weight to 0 
	if( (x - r.position.x) / r.direction.x < 0 || (y - r.position.y) / r.direction.y < 0 || (z - r.position.z) / r.direction.z < 0) {
		w = 0;
	}

	return dvec4(x,y,z,w);
}

dvec4 setIntersectionPoint(inout Ray r, dmat4 quadric, dvec4 closestHitpoint)
{
	double x = closestHitpoint.x;
	double y = closestHitpoint.y;
	double z = closestHitpoint.z;
	double w = closestHitpoint.w;

	double a_11 = quadric[0][0];
	double a_12 = quadric[0][1];
	double a_13 = quadric[0][2];
	double a_14 = quadric[0][3];
	double a_22 = quadric[1][1];
	double a_23 = quadric[1][2];
	double a_24 = quadric[1][3];
	double a_33 = quadric[2][2];
	double a_34 = quadric[2][3];
	double a_44 = quadric[3][3];

	double fx = 2*a_14 + 2*a_11*x + 2*a_12*y + 2*a_13*z;
	double fy = 2*a_24 + 2*a_12*x + 2*a_22*y + 2*a_23*z;
    double fz = 2*a_34 + 2*a_13*x + 2*a_23*y + 2*a_33*z;

	dvec4 normal = normalize(dvec4(fx,fy,fz,0));
	r.position = dvec3(x,y,z); // new position = intersection point
	r.weight = w; // unchanged, if ray did not miss surface, else 0
	return normal;
}

/**
* returns intersection point for a quadric element
* @param r		 	current ray
* @param quadric	4x4 matrix with quadric parameters, upper right part + diagonal for a_11..a_33
* @param icurv 		sign of p/q formula for calculating intersection point (p/2 ICURV sqrt( (p/2)² -q)), quadric[1,0]
*
* @return			dvec4(intersection point in element coordinates, weight)
*/
dvec4 getIntersectionPointEnrico(Ray r, dmat4 quadric)
{	
	double w = r.weight;
	int icurv = int(quadric[1][0]);
	int cs = 0;
	if (abs(rayData[uint(gl_GlobalInvocationID)].direction[1]) >= abs(rayData[uint(gl_GlobalInvocationID)].direction[0]) && abs(rayData[uint(gl_GlobalInvocationID)].direction[1]) >= abs(rayData[uint(gl_GlobalInvocationID)].direction[2])) {
		cs = 1;
	}else if (abs(rayData[uint(gl_GlobalInvocationID)].direction[2]) >= abs(rayData[uint(gl_GlobalInvocationID)].direction[0]) && abs(rayData[uint(gl_GlobalInvocationID)].direction[2]) >= abs(rayData[uint(gl_GlobalInvocationID)].direction[1])) {
		cs = 2;
	}
	uint f_001 = uint(cs/2);
	uint f_010 = cs%2;
	uint f_011 = uint(cs+1/2);
	uint f_012 = cs;
	uint f_0x1 = uint(cs/2);
	uint f_100 = (uint((cs+1)/2)+1)%2;
	uint f_101 = ((cs%2)+1)%2;
	uint f_110 = (uint(cs/2)+1)%2;
	uint f_112 = int(cs/2)+1;
	//uint f_1x0 = (cs/2)%2;
	uint f_131 = ((cs%2)*2)+1;
	uint f_220 = ((uint(cs/2)+1)%2)*2;
	uint f_221 = ((uint(cs/2)+1)%2)+1;

    //Formula: ((x+1)%3)/(x-1) and (x%3)/(x-1)
	double firstParam = rayData[uint(gl_GlobalInvocationID)].direction[f_100] / rayData[uint(gl_GlobalInvocationID)].direction[cs];
	double secondParam = rayData[uint(gl_GlobalInvocationID)].direction[f_221] / rayData[uint(gl_GlobalInvocationID)].direction[cs];
	double params[2] = {firstParam, secondParam};
	//dvec4 normal;
	xyznull[uint(gl_GlobalInvocationID)] = dvec4(0.0,0.0,0.0,0.0);
	xyznull[uint(gl_GlobalInvocationID)][f_100] = rayData[uint(gl_GlobalInvocationID)].position[f_100] - firstParam * rayData[uint(gl_GlobalInvocationID)].position[cs];
	xyznull[uint(gl_GlobalInvocationID)][f_221] = rayData[uint(gl_GlobalInvocationID)].position[f_221] - secondParam * rayData[uint(gl_GlobalInvocationID)].position[cs];
	xyznull[uint(gl_GlobalInvocationID)][3] = 0;

	const int d_sign = int(sign(rayData[uint(gl_GlobalInvocationID)].direction[cs]) * icurv);

	double a = quadric[cs][cs] + 2*quadric[0][f_112]*firstParam + quadric[f_100][f_100]*firstParam*firstParam + 2*quadric[f_011][2]*secondParam + 2*quadric[f_100][f_221]*firstParam*secondParam + quadric[f_221][f_221]*secondParam*secondParam;
	double b = quadric[cs][3] + quadric[f_100][3]*firstParam + quadric[f_221][3]*secondParam + (quadric[0][f_112] + quadric[f_100][f_100]*firstParam + quadric[f_100][f_221]*secondParam)*xyznull[uint(gl_GlobalInvocationID)][f_100] + (quadric[f_011][2] + quadric[f_100][f_221]*firstParam + quadric[f_221][f_221]*secondParam)*xyznull[uint(gl_GlobalInvocationID)][f_221];
	double c = quadric[3][3] + quadric[f_100][f_100]*xyznull[uint(gl_GlobalInvocationID)][f_100]*xyznull[uint(gl_GlobalInvocationID)][f_100] + 2*quadric[f_221][3]*xyznull[uint(gl_GlobalInvocationID)][f_221] + quadric[f_221][f_221]*xyznull[uint(gl_GlobalInvocationID)][f_221]*xyznull[uint(gl_GlobalInvocationID)][f_220] + 2*xyznull[uint(gl_GlobalInvocationID)][f_100]*(quadric[f_100][3] +quadric[f_100][f_221]*xyznull[uint(gl_GlobalInvocationID)][f_221]);

	
	double bbac = b*b - a*c;
	if (bbac < 0) {
		w = 0.0;
		xyznull[uint(gl_GlobalInvocationID)][cs] = - xyznull[uint(gl_GlobalInvocationID)][f_131]/params[f_0x1]; 	// x such that y=0
		return dvec4(1.0/0.0,1.0/0.0,1.0/0.0, 0);
	}
	else{
		if (abs(a) > abs(c)*1e-10) {
			xyznull[uint(gl_GlobalInvocationID)][cs] = (-b + d_sign*sqrt(bbac)) / a;
		}else{
			xyznull[uint(gl_GlobalInvocationID)][cs] = (-c/2)/b;
		}
	}
	xyznull[uint(gl_GlobalInvocationID)][f_100] = xyznull[uint(gl_GlobalInvocationID)][f_100] + firstParam * xyznull[uint(gl_GlobalInvocationID)][cs];
	xyznull[uint(gl_GlobalInvocationID)][f_221] = xyznull[uint(gl_GlobalInvocationID)][f_221] + secondParam*xyznull[uint(gl_GlobalInvocationID)][cs];
	
	if(w > 0.0){
		return dvec4(xyznull[uint(gl_GlobalInvocationID)][0],xyznull[uint(gl_GlobalInvocationID)][1],xyznull[uint(gl_GlobalInvocationID)][2], w);
	}
	else{
		return dvec4(1.0/0.0,1.0/0.0,1.0/0.0, 0);
	}
}

/**
* approximates intersection point with non-quadric element with Newton iteration
* 
* @param r 				current ray
* @param longRadius		?
* @param shortRadius	?
* 
* @return normal at intersection point, changes Ray position in place
*/
dvec4 iteratTo(inout Ray r, double longRadius, double shortRadius) {
	double isigro = sign(shortRadius);
	// sign radius: +1 = concave, -1 = convex
	
	int n = 0;
	//double aln = r.direction.x / r.direction.z;
	//double amn = r.direction.y / r.direction.z;

	dvec4 normal = dvec4(0,0,0,0);
	double zz = 0.0;
	double xx, yy;
	double dz = 0.0;
	dvec3 normalized_dir = dvec3(r.direction) / r.direction.z;
	
	// while not converted
	do {
		zz = zz + dz;
		xx = r.position.x + normalized_dir.x*(zz - r.position.z);
		if(xx*xx > shortRadius*shortRadius) {
			xx = xx / abs(xx) * 0.95*shortRadius;
		}
		yy = r.position.y + normalized_dir.y*(zz - r.position.z);
		double sq = sqrt(shortRadius*shortRadius - xx*xx);
		double rx = (longRadius - shortRadius + isigro*sq);

		normal.x = (-2*xx*isigro / sq) * rx;
		normal.y = -2*(yy - longRadius);
		normal.z = -2*zz;

		double func = -rx*rx + (yy - longRadius)*(yy-longRadius) + zz*zz;
		double df = normalized_dir.x*normal.x + normalized_dir.y*normal.y + normal.z;//dot(normalized_dir, dvec3(normal));
		dz = func / df;
		n += 1;
		if (n >= 50) {
			normal = intersectionPoint(r, dmat4(0,0,0,0, 1,0,0,0, 0,0,0,-1, 0,0,0,0));
			r.weight = 0; // -4 in old ray. thrown away or still in use?
			return normal;
		}
		
	} while (abs(dz) > 0.0001);

	r.position = dvec3(xx,yy,zz);
	return normalize(normal);

}

dvec4 getTorusNormal(Ray r, double shortRadius, double longRadius) {
	double isigro = sign(shortRadius);
	dvec4 normal;

	double sq = sqrt(shortRadius*shortRadius - r.position.x*r.position.x);
	double rx = (longRadius - shortRadius + isigro*sq);

	normal.x = (-2*r.position.x*isigro / sq) * rx;
	normal.y = -2*(r.position.y - longRadius);
	normal.z = -2*r.position.z;

	return normal;
}

/**
* calculates and returns the intersection of a given ray with a given optical element
* if element is not hit, return (inf, inf, inf, 0)
* @param r						current Ray in global coordinates
* @param elementIndex			index of current optical element in list of all elements
* @param whichIntersection		whether to get first or second intersection (usually first)
* 
* @return ELEMENT coordinates of intersection point of ray with optical element
*/
dvec4 getOpticalElementIntersection(Ray r, uint elementIndex){

	int type = int(quadricData[elementIndex].surfaceParams[3][0]);
	Element e = quadricData[elementIndex];
	dvec4 currentIntersection;
	if(type > 7){
		return dvec4(1.0/0.0,1.0/0.0,1.0/0.0, 0);
	}
	if(type == 4) { // rzp
		r.position.z = r.position.z - e.elementParameters[3][2];
	}

	//rayData[uint(gl_GlobalInvocationID)] = rayMatrixMult(rayData[uint(gl_GlobalInvocationID)], q.inTrans); // ray/global to element coordinates, misalignment
	r = rayMatrixMult(r, e.inTrans); // image plane is the x-y plane of the coordinate system
	if(type == 5) { // image plane
		double offset = 0 - r.position.z; // length between ray origin (intersection point of previous element) and image plane
		currentIntersection.x = r.position.x + ((r.direction.x / r.direction.z) * offset); // scale x-slope of ray (l/n) by z-length between origin and image plane
		currentIntersection.y = r.position.y + ((r.direction.y / r.direction.z) * offset);
		currentIntersection.z = 0;
		// the ray should not face away from the image plane. If that is the case, set the weight of the intersection to 0 so that it is not considered in the tracing process
		// also the image plane detects only rays from one side
		currentIntersection.w = r.weight * int(r.direction.z > 0);
		// * int(r.direction.z > 0); // * (1-int((r.direction.z > 0 && r.position.z > 0) || (r.direction.z < 0 && r.position.z < 0)));
		r = rayMatrixMult(r, e.outTrans); // do not know if this is necessary as the ray r is not defined as inout
		return currentIntersection;
	}
	else if(type == 6 || (type == 4 && e.elementParameters[1][0] == 2)) { // toroidal mirror or toroidal rzp
		double longRadius = e.surfaceParams[0][0];
		double shortRadius = e.surfaceParams[0][1];
	
		dvec4 normal = iteratTo(r, longRadius, shortRadius);
		currentIntersection = dvec4(r.position, r.weight);
		// intersection point is in the negative direction (behind the position when the direction is followed forwards), set weight to 0 
		if( (currentIntersection.x - r.position.x) / r.direction.x < 0 || (currentIntersection.y - r.position.y) / r.direction.y < 0 || (currentIntersection.z - r.position.z) / r.direction.z < 0) {
			currentIntersection.w = 0;
		}

		return currentIntersection;
	}
	currentIntersection = getIntersectionPoint(r, e.surfaceParams);
	
	r = rayMatrixMult(r, e.outTrans);
	return currentIntersection; // in element coordinate system
}


// returns angle between ray direction and surface normal at intersection point
double getTheta(Ray r, dvec4 normal) {
	normal = normalize(normal);
	double ar = dot(dvec3(normal), r.direction);
	// cut to interval [-1,1]
	if(ar < -1.0) ar = -1.0;
	else if(ar > 1.0) ar = 1.0;

	double theta = PI - r8_acos(ar);
	int gt = int(theta > PI);
	// theta in [0, pi]
	theta = gt * (PI - theta) + (1-gt) * theta;
	return theta;

}

/** calculates cosinus of transmittance angle with snell's law 
 * cosinus is needed in fresnel formula
 * sin(transmittance_anlge) = (cn1 / cn2) * sin(incidence_angle)
 * 
 * @param cos_incidence			cosinus of complex incidence angle
 * @param cn1					complex refractive index of material from which the ray is coming
 * @param cn2					complex refractive index of material into which the ray is going
 * @return cos_transmittance 	cosinus of complex transmittance angle 
 */
dvec2 snell(dvec2 cos_incidence, dvec2 cn1, dvec2 cn2) {
	dvec2 sin_incidence = cx_sqrt( cx_sub(dvec2(1,0), cx_pow(cos_incidence, 2)) );
	dvec2 refractive_ratio = cx_div(cn1, cn2);
	dvec2 sin_transmittance = cx_mul(sin_incidence, refractive_ratio);
	dvec2 cos_transmittance = cx_sqrt( cx_sub(dvec2(1,0), cx_pow(sin_transmittance, 2)));
	return cos_transmittance;
}

/** calculates complex s- and p-polarization with fresnel formulas
 * @param cn1					complex refractive index of material from which the ray is coming
 * @param cn2					complex refractive index of material into which the ray is going
 * @param cos_incidence			cosinus of complex incidence angle
 * @param cos_transmittance 	cosinus of complex transmittance angle 
 * @return complex_S			complex s-polarization 
 * @return complex_P			complex p-polarization 
 *
 */
void fresnel(dvec2 cn1, dvec2 cn2, dvec2 cos_incidence, dvec2 cos_transmittance, inout dvec2 complex_S, inout dvec2 complex_P) {
	dvec2 mat1_incidence = cx_mul( cn1, cos_incidence ); // material one (incoming side)
	dvec2 mat1_transmittance = cx_mul( cn1, cos_transmittance );
	dvec2 mat2_incidence = cx_mul( cn2, cos_incidence ); // material two (into which the ray goes)
	dvec2 mat2_transmittance = cx_mul( cn2, cos_transmittance );

	complex_S = - cx_div(cx_sub(mat1_incidence, mat2_transmittance) , cx_add(mat1_incidence, mat2_transmittance));
	complex_P = - cx_div(cx_sub(mat1_transmittance, mat2_incidence) , cx_add(mat1_transmittance, mat2_incidence));
	return;
}

/** computes complex s and p polarization over all layers with fresnel and snell's law
 * @param energy 				energy of ray
 * @param incidence_angle		normal incidence angle
 * @return complex_S			complex s-polarization
 * @return complex_P			complex p-polarization
 */
void reflectance(double energy, double incidence_angle, inout dvec2 complex_S, inout dvec2 complex_P) {
	dvec2 cos_incidence = dvec2( r8_cos(incidence_angle), 0.0); // complex number, initialization only for first layer, the others are then derived from this with snell's law
	
	// todo number of layers: loop over layers from top to bottom, transmittance angle for each layer, so far only one layer (substrate?)
	// store cosinuses in array, bc needed in later loop for fresnel (or maybe only one loop is enough?)
	// todo refractive indices of materials in extra buffer?
	dvec2 cn1 = dvec2(1,0);
	dvec2 cn2 = dvec2(1,0);
	dvec2 cos_transmittance = snell(cos_incidence, cn1, cn2);

	// todo again iterate over layers but from bottom to top, update s and p polarization in each iteration:
	fresnel(cn1, cn2, cos_incidence, cos_transmittance, complex_S, complex_P);
	// todo roughness (uses wavelength/energy)
	// todo other calculations for layers that are not substrate (which is the first layer)
	return;
}
/**
 * computes complex number a + i*b in euler form: 
 * euler = r * e^(i * phi) where r = sqrt(a**2 + b**2) = radius and phi = atan2(a,b) = (absolute) phase
 */
dvec2 cartesian_to_euler(dvec2 complex) {
	double r = complex.x*complex.x + complex.y*complex.y; // r = sqrt(a**2 + b**"), why not take sqrt in fortran code?
	dvec2 euler;
	if(r < 0 || r > 1) {
		euler = dvec2(1.0/0.0, 1.0/0.0);
		return euler;
	}
	euler = dvec2(r, r8_atan2(complex.x, complex.y)); // TODO in grad or in rad?
	return euler;
}

/** computes the difference in the phases of 2 complex number written in euler form: r * e^(i * phi)
 * @param euler1 		first complex number
 * @param euler2		second complex number
 * @return delta = phi1 - phi2, in [-pi/2, pi/2] degrees
 */
double phase_difference(dvec2 euler1, dvec2 euler2) {
	double delta = euler2.y - euler1.y;
	delta = delta - int(delta > 180)*360.0 + int(delta < -180)*360.0;
	return delta;
}

/** efficiency calculation
 * uses complex numbers for s- and p-polarisation: 
 * complex_S = a + i*b as dvec2. 
 * in euler form: complex_S = r * e^(i * phi) where r = sqrt(a**2 + b**2) = radius and phi = atan2(a,b) = (absolute) phase
 * @param real_S				inout, s-polarization (senkrecht), radius of complex number
 * @param real_P				inout, p-polarization (parallel), radius of complex number
 * @param delta					phase difference between angles of complex numbers complex_S, complex_P
 * @param incidence_angle		normal incidence angle
 * @param others
 */
void efficiency(Ray r, inout double real_S, inout double real_P, inout double delta, double incidence_angle) {
	dvec2 complex_S, complex_P;
	reflectance(r.energy, incidence_angle, complex_S, complex_P);

	dvec2 euler_P = cartesian_to_euler(complex_P);
	dvec2 euler_S = cartesian_to_euler(complex_S);

	delta = phase_difference(euler_P, euler_S);
	real_S = euler_S.x;
	real_P = euler_P.x;
}

/**
turn the normal vector through x_rad and z_rad
@params:  	normal: the normal vector
			x_rad: angle in rad for x-axis
			z_rad: angle in rad for z-axis
returns modified normal vector
*/
dvec4 normal_cartesian(dvec4 normal, double x_rad, double z_rad){
	double FX = normal[0];
	double FY = normal[1];
	double FZ = normal[2];

	double cosx = r8_cos(x_rad);
	double sinx = r8_sin(x_rad);
	double cosz = r8_cos(z_rad);
	double sinz = r8_sin(z_rad);

	// put in matrix mult?
	double FY2 = FY*cosz + FZ*sinz;
	normal[0] = FX*cosx + FY2*sinx;
	normal[1] = FY2*cosx - FX*sinx;
	normal[2] = FZ*cosz - FY*sinz;

	return normal;
}

/**
turn the normal vector through x_rad and z_rad
@params:  	normal: the normal vector
			x_rad: angle in rad for x-axis
			z_rad: angle in rad for z-axis
returns modified normal vector
*/
dvec4 normal_cylindrical(dvec4 normal, double x_rad, double z_rad) {
	double normFXFY = sqrt(normal[0]*normal[0] + normal[1]*normal[1]);
	double arcTanFXFY = r8_atan2(normal[1], normal[0]);
	double sinz = r8_sin(z_rad);
	double cosz = r8_cos(z_rad);

	normal[0] = r8_cos(x_rad+arcTanFXFY)*(normFXFY*cosz+normal[2]*sinz);
	normal[1] = r8_sin(x_rad+arcTanFXFY)*(normFXFY*cosz+normal[2]*sinz);
	normal[2] = normal[2]*cosz-normFXFY*sinz;

	return normal;

}

/**
adds slope error to the normal
@params:
	normal: normal vector
	slopeX: sigma-slope error in x-y plane (chi) (RMS) in arcsec
	slopeZ: sigma-slope error in y-z plane (psi) (RMS) in arcsec
	O_type: cartesian or cylindrical type of slope error (0=cartesian, 1=cylindrical) (1 only for ellipsis relevant)
returns new normal if there is a slope error in either x or z direction or the unmodified normal otherwise.
*/
dvec4 tanger(dvec4 normal, double slopeX, double slopeZ, int O_type, inout uint64_t ctr) {
	// only calculate the random number if at least one slope error is not 0, since the calculation is costly (sin, cos, log involved)
	if(slopeX != 0 || slopeZ != 0) {
		double random_values[2] = double[2] (squaresNormalRNG(ctr, 0, slopeX), squaresNormalRNG(ctr, 0, slopeZ));

		/*double x = random_values[0] * slopeX; // to get normal distribution from std.-norm. multiply by sigma (=slopeX) -> mu + x * sigma but mu=0 here
		double z = random_values[1] * slopeZ;*/

		double x_rad = deg2rad(random_values[0]/3600.0);
		double z_rad = deg2rad(random_values[1]/3600.0);

		if (O_type == 0) { // default
			normal = normal_cartesian(normal, x_rad, z_rad);
		}else if(O_type == 1) {
			normal = normal_cylindrical(normal, x_rad, z_rad);
		}
	}

	return normal;
}


/**
calculates DX and DZ (line spacing in x and z direction) at a given point for a given direction on the grating
@params: lots
@returns: (inplace) DX, DZ
*/
void RZPLineDensity(Ray r, dvec4 normal, int IMAGE_TYPE, int RZP_TYPE, int DERIVATION_METHOD, double zOffsetCenter,
double risag, double rosag, double rimer, double romer, double alpha, double beta, double Ord, double WL,
inout double DX, inout double DZ) {

	double FX = normal.x;
	double FY = normal.y;
	double FZ = normal.z;
	double X = r.position.x;
	double Y = r.position.y;
	double Z = r.position.z;

	if(RZP_TYPE == 1) // meridional (wie VLS grating)
		X = 0;

	// avoid calculating the same sinus/cosinus multiple times (costly)
	double s_beta = r8_sin(beta);
	double c_beta = r8_cos(beta);
	double s_alpha = r8_sin(alpha);
	double c_alpha = r8_cos(alpha);

	/*if (DERIVATION_METHOD == 1) {
		DX = getLineDensity1d(ptr_dx,x,z);
		DZ = getLineDensity1d(ptr_dz,x,z);
		return;
	}*/
	double xi;
	double yi;
	double zi;
	double xm;
	double ym;
	double zm;

	if(IMAGE_TYPE == 0) { // point to point (standard)
		if(FX == 0 && FZ == 0) { // plane
			zi = -(risag * c_alpha+Z);
			xi = X;
			yi = risag * s_alpha;
			zm = rosag * c_beta - Z;
			xm = X;
			ym = rosag * s_beta;
		}else{ // more general case, can be reduced to the plane with normal = (0,1,0) and y = 0
			zi = FX*FZ*X - (FX*FX + FY*FY)*(Z + risag*c_alpha) + FY*FZ*(Y - risag*s_alpha);
			xi = (FY*X - FX*Y + FX*risag*s_alpha);
            yi = -(FX*X) - FY*Y - FZ*Z - FZ*risag*c_alpha + FY*risag*s_alpha;
            zm = FX*FZ*X + (FX*FX + FY*FY)*(-Z + rosag*c_beta) + FY*FZ*(Y - rosag*s_beta);
            xm = (FY*X - FX*Y + FX*rosag*s_beta);
            ym = -(FX*X) - FY*Y - FZ*Z + FZ*rosag*c_beta + FY*rosag*s_beta;
		}
	}else if(IMAGE_TYPE == 1){ // astigmatic to astigmatix
		double s_rim = sign(rimer);
		double s_rom = sign(romer);
		double c_2alpha = r8_cos(2*alpha);
		double c_2beta = r8_cos(2*beta);
		if(FX == 0 && FZ == 0){ //   !plane

			zi = s_rim*(rimer*c_alpha+Z);
        	xi =(s_rim*X*(c_alpha*Z-2*s_alpha*s_alpha*rimer+s_alpha*Y+rimer)) / (c_alpha*Z-2*s_alpha*s_alpha*risag+s_alpha*Y+risag);
            yi = s_rim*(-rimer*s_alpha+Y);
            zm = s_rom*(romer*c_beta-Z);
            xm = (s_rom*X*(-c_beta*Z-2*s_beta*s_beta*romer+s_beta*Y+romer)) / (c_beta*Z+2*s_beta*s_beta*rosag-s_beta*Y-rosag);
            ym = s_rom*(romer*s_beta-Y);
		}else{
			double denominator = Z*c_alpha + risag*c_2alpha + Y*s_alpha;
			double nominator = X*(Z*c_alpha + rimer*c_2alpha + Y*s_alpha);
			zi = s_rim*((FX*FX + FY*FY)*(Z + rimer*c_alpha) - FY*FZ*(Y - rimer*s_alpha) - (FX*FZ*nominator) / denominator);
			xi = s_rim*(-(FX*Y) + FX*rimer*s_alpha + (FY*nominator) / denominator);
			yi = s_rim*(FZ*(Z + rimer*c_alpha) + FY*(Y - rimer*s_alpha) + (FX*nominator) / denominator);

			denominator = (-(Z*c_beta) + rosag*c_2beta + Y*s_beta);
			nominator = X*(-(Z*c_beta) + romer*c_2beta + Y*s_beta);
			zm = s_rom*((FX*FX + FY*FY)*(-Z + romer*c_beta) + FY*FZ*(Y - romer*s_beta) + (FX*FZ*nominator)/denominator);
			xm = s_rom*(FX*(Y - romer*s_beta) - (FY*nominator)/denominator);
			ym = s_rom*(FZ*(-Z + romer*c_beta) + FY*(-Y + romer*s_beta) - (FX*nominator)/denominator);
		}
		double ris = sqrt(zi*zi + xi*xi + yi*yi);
		double rms = sqrt(zm*zm + xm*xm + ym*ym);

		double ai = zi/ris;
		double bi = -xi/ris;
		double am = -zm/rms;
		double bm = xm/rms;

		//double ci = yi/ris; // for what?
		//double cm = -ym/rms;

		DZ = (ai+am)/(WL*Ord);
		DX = (-bi-bm)/(WL*Ord);

		return;
	}

	double ris = sqrt(zi*zi + xi*xi + yi*yi);
    double rms = sqrt(zm*zm + xm*xm + ym*ym);

	double ai = xi/ris;
	double am = xm/rms;
	double bi = zi/ris;
	double bm = zm/rms;


	DX = (ai+am)/(WL*Ord);
	DZ = (-bi-bm)/(WL*Ord);

	return;

}

/**
calculates refracted ray
@params: 	r: ray
			normal: normal at intersection point of ray and element
			az: line spacing in z direction
			ax: line spacing in x direction
@returns: refracted ray (position unchanged, direction changed), weight = 0 if "ray beyond horizon"
*/
Ray refrac2D(Ray r, dvec4 normal, double az, double ax) {
	double eps1 = -r8_atan(normal.x/normal.y);
    double del1 = r8_asin(normal.z);

	double cos_d = r8_cos(-del1);
	double sin_d = r8_sin(-del1);
	double cos_e = r8_cos(-eps1);
	double sin_e = r8_sin(-eps1);
	dmat3 rot = dmat3(cos_e, cos_d*sin_e, sin_d*sin_e,
				-sin_e, cos_d*cos_e, sin_d*cos_e,
				0, -sin_d, cos_d);
	dmat3 inv_rot = dmat3(cos_e, -sin_e, 0,
				cos_d*sin_e, cos_d*cos_e, -sin_d,
				sin_d*sin_e, sin_d*cos_e, cos_d);
	r.direction = rot * r.direction;

	double x1 = r.direction.x - ax;
	double z1 = r.direction.z - az;
	double y1 = 1-x1*x1-z1*z1;

	if (y1 > 0){
	   y1 = sqrt(y1);

	   r.direction.x = x1;
	   r.direction.y = y1;
	   r.direction.z = z1;
	}else{ // beyond horizon - when divergence too large
	   r.weight = 0.0;
	}
	r.direction = inv_rot * r.direction;
	return r;
}

// refraction function used for gratings
Ray refrac(Ray r, dvec4 normal, double linedensity){
	double xy = normal[0] / normal[1];
	double zy = normal[2] / normal[1];
	double sqq = sqrt(1 + zy*zy + xy*xy);
	double an_x = xy/sqq;
	double an_y = -1.0/sqq;
	double an_z = zy/sqq;

	double eps1 = r8_atan(an_x/ an_y); //-atan(an_x/an_z) around z, chi
	double del1 = r8_asin(an_z); // sign(an_z) * r8_atan(sqrt( (an_z*an_z) / (1-an_z*an_z) )); // -asin(an_z); // -asin around x, psi
	double cos_d = r8_cos(del1);
	double a1 = linedensity * cos_d;
	double sin_d = r8_sin(-del1);
	double cos_e = r8_cos(-eps1);
	double sin_e = r8_sin(-eps1);
	dmat4 rot = dmat4(cos_e, cos_d*sin_e, sin_d*sin_e, 0,
				-sin_e, cos_d*cos_e, sin_d*cos_e, 0,
				0, -sin_d, cos_d, 0,
				0,0,0,1);
	dmat4 inv_rot = dmat4(cos_e, -sin_e, 0, 0,
				cos_d*sin_e, cos_d*cos_e, -sin_d, 0,
				sin_d*sin_e, sin_d*cos_e, cos_d, 0,
				0,0,0,1);
	r.direction = dvec3(rot * dvec4(r.direction,0));

	double y1 = (r.direction[1]*r.direction[1]+r.direction[2]*r.direction[2]-((r.direction[2]-a1)*(r.direction[2]-a1)));
	if (y1 > 0){
		y1 = sqrt(y1);
		r.direction[1] = y1;
		r.direction[2] -= a1;
	}else{
	   r.weight = 0.0;
	}
	r.direction = dvec3(inv_rot * dvec4(r.direction,0));
	return r;
}


/** variable line spacing for gratings
@params
	lineDensity: general line density?
	z: z-coordinate of ray position
	vls[6]: 6 vls parameters given by user
@returns line density specifically for this z-coordinate
*/
double vlsGrating(double lineDensity, double z, double[6] vls) {
	// lineDensity = lineDensity * (1 + 2*b2*z + 3*b3*z**2 + 4*b4*z**3 + 5*b5*z**4 + 6*b6*z**5 + 7*b7*z**6)
	double z2 = z*z;
	double z3 = z2*z;
	double z4 = z3*z;
	double z5 = z4*z;
	double z6 = z5*z;
	double a = lineDensity * (1 + 2*vls[0]*z + 3*vls[1]*z2 + 4*vls[2]*z3 + 5*vls[3]*z4 + 6*vls[4]*z5 + 7*vls[5]*z6);
	return a;
}


/*
* simplified refraction function used for plane gratings
* normal is always the same (0,1,0) -> no rotation and thus no trigonometric functions necessary
* @param r			ray
* @param normal		normal at ray-object intersection (for planes always (0,1,0))
* @param a			a = WL * D0 * ORD * 1.e-6  with D0: line density (l/mm); WL:wavelength (nm); ORD order of diffraction
*/
Ray refrac_plane(Ray r, dvec4 normal, double a){
	double y1 = r.direction[1]*r.direction[1] + r.direction[2]*r.direction[2] - (r.direction[2]-a)*(r.direction[2]-a);
	if (y1 > 0){
		y1 = sqrt(y1);
		r.direction[1] = y1;
		r.direction[2] = r.direction[2] - a;
	}else{
	   r.weight = 0.0; // status?
	}
	return r;
}

/**
checks whether the ray is hit by a central beam stopper which may be rectangular (width: xStop/yStop)
or circular.
if so the ray is thrown away.
if xStop is negative, then a circular shape of radius xStop is assumed (from RAY.FOR)
@params		x,y				x/y-coord. of ray direction
			xStop, yStop	shape of beam stopper
			weight			current weight of the ray, is changed if ray is stopped
@return
	new weight
*/
double stopBox(double x, double y, double xStop, double yStop, double weight) {
	double w = weight;
	// if w == 0 return
	if(w != 0) {
		if(xStop > 0) {
			if(abs(x) < xStop && abs(y) < yStop) {
				w = 0;
			}
		}else{
			double radius = sqrt((x/xStop)*(x/xStop) + (y/yStop)*(y/yStop));
			if(radius <= 1) w = 0;
		}
	}
	return w;
}

/**returns first bessel function of parameter v*/
double bessel1(double v) {
	if(v < 0.0 || v > 20.0) {
		return 0.0;
	}

	double sum = 0;
	int large = 30;

	double PO1;
	double PO2;
	double FA1;
	for(int small = 0; small<=large; small++) {
		PO1 = dpow(-1.0, small);
		PO2 = dpow(v/2.0, 2*small+1);
		FA1 = fact(small);
		sum += (PO1 / (FA1*FA1*(small+1))) * PO2;
	}
	return sum;
}

/**
calculates the Bessel diffraction effects on circular slits and on circular zoneplates
@params:	radius		radius < 0 (mm)
			wl			wavelength (nm)
			dphi, dpsi  angles of diffracted ray
@returns
	results stored in dphi, dpsi (inout)
*/
void bessel_diff(double radius, double wl, inout double dphi, inout double dpsi, inout uint64_t ctr) {
	double b = abs(radius) * 1e06;
	double ximax = 5.0*wl/b;

	double rn1[3];
	double c = -1;
	while(c < 0) { // while c = wd - rn1[2] < 0 continue
		rn1 = double[3] (squaresDoubleRNG(ctr), squaresDoubleRNG(ctr), squaresDoubleRNG(ctr));
		dphi = rn1[0] * ximax;
		dpsi = rn1[1] * ximax;
		double xi = sqrt(0.5 * (dphi*dphi + dpsi*dpsi));
		double u = 2.0 * PI * b * xi / wl;
		double wd = 1;
		if(u != 0) {
			wd = 2.0 * bessel1(u) / u;
			wd = wd*wd;
		}
		c = wd - rn1[2];
	}

	// 50% neg/pos sign
	dphi = sign(squaresDoubleRNG(ctr) - 0.5) * dphi;
	dpsi = sign(squaresDoubleRNG(ctr) - 0.5) * dpsi;

}

/**
* calculates fraunhofer diffraction effects on rectangular slits
* @param dim		dimension (x or y) (mm)
* @param wl			wavelength (nm)
* @param dAngle 	diffraction angle (inout)
* @param ctr		counter for random number generator
* @return result stored in dAngle
*/
void fraun_diff(double dim, double wl, inout double dAngle, inout uint64_t ctr){
	if (dim==0) return; // no diffraction in this direction
	double b = dim * 1e06; 		// slit opening
	double div = 10.0 * wl/b;	// up to 2nd maximum

	double rna[2]; // 2 uniform random numbers in [0,1]
	double c = -1;
	while(c < 0) { // while c = wd - uni[1] < 0 continue
		rna = double[2] (squaresDoubleRNG(ctr), squaresDoubleRNG(ctr));
		dAngle = (rna[0]-0.5) * div;
		double u = PI * b * r8_sin(dAngle) / wl;
		double wd = 1;
		if(u != 0) {
			wd = r8_sin(u) / u;
			wd = wd*wd;
		}
		c = wd - rna[1];
	}
}

void diffraction(int iopt, double xLength, double yLength, double wl, inout double dPhi, inout double dPsi, inout uint64_t ctr) {
	if(wl <= 0) return;

	double yl = yLength;
	double xl = xLength;

	if(xLength > 0) {	// rectangular slit, zoneplate
		if(iopt == 3) { 	// zoneplate
			if(yLength > 0) {	// in x direction
				yl = 0;
			}
			else if(yLength < 0) { // in y direction, what about ==0?
				xl = 0;
			}
		}
		fraun_diff(xl, wl, dPhi, ctr);
		fraun_diff(yl, wl, dPsi, ctr);
	}else{	// circular slit
		if(iopt == 1){
			xl = yLength; // SL R_max
		}
		bessel_diff(xl, wl, dPhi, dPsi, ctr);
	}
}

/**
* calculates resulting ray for a slit
* @param r				ray to trace in element coordinates
* @param elementIndex	index of element in data buffer
* @param ctr			counter for random number generator, always inout
* @param intersection	intersection point in ELEMENT coordinates
*
* output: diffracted Ray with intersection point as position, reflection as direction in beam coordinates and possibly modified weight in ELEMENT coordinates
*/
Ray traceSlit(Ray r, const int elementIndex, inout uint64_t ctr, dvec4 intersection) {
	Element slit = quadricData[elementIndex];
	
	// store old position, needed for pathlength calculation
	dvec3 old_position = r.position;
	
	//dvec4 normal = intersectionPoint(r, q.surfaceParams); // if it is not sure whether the given intersection is correct, use this (recalculate the intersection)
	dvec4 normal = setIntersectionPoint(r, slit.surfaceParams, intersection);
	
	double x_extent = slit.objectParameters[0][0]; // width
	double y_extent = slit.objectParameters[0][1]; // height
	double xStop = slit.elementParameters[0][0]; // beamstop width
	double yStop = slit.elementParameters[0][1]; // beamstop heigth
	// slit lies in x-y plane instead of x-z plane as other elements
	r.weight = wasteBox(r.position[0], r.position[1], x_extent, y_extent, r.weight);
	r.weight = stopBox(r.position[0], r.position[1], xStop, yStop, r.weight);

	if(r.weight < 1.0) {
		// rays that missed an element get weight 2
		r.weight = 2;
		return r;
	}

	// add the travelled distance from the previous position to the new intersection to pathlength (both are in the same coordinate system so we do not need to transform back to world coordinates??)
	r.pathLength += length(old_position - r.position);
	r.lastElement = elementIndex+1;
	
	double psi = -r8_asin(r.direction.y);
	double phi = r8_asin(r.direction.x/r8_cos(psi));
	double delPhi = 0;
	double delPsi = 0;
	int iopt = 1; // 1 = slit, 3 = zone plate
	double wavelength = slit.elementParameters[1][0]; // from parameters or per ray
	diffraction(iopt, x_extent, y_extent, wavelength, delPhi, delPsi, ctr);
	phi = phi + delPhi;
	psi = psi + delPsi;
	
	// new direction from angles
	cosini(r, phi,psi);

	r.order = 0;
	return r;
}

/**
* calculates resulting ray for a toroid
* @param r				ray to trace in element coordinates
* @param elementIndex	index of element in data buffer
* @param ctr			counter for random number generator, always inout
* @param intersection	intersection point in ELEMENT coordinates
*
* output: reflected Ray with intersection point as position, reflection as direction in ELEMENT coordinates and possibly modified weight
*/
Ray traceToroid(Ray r, const int elementIndex, inout uint64_t ctr, dvec4 intersectionPoint) {
	Element tor = quadricData[elementIndex];

	// store old position, needed for pathlength calculation
	dvec3 old_position = r.position;
	
	double longRadius = tor.surfaceParams[0][0];
	double shortRadius = tor.surfaceParams[0][1];
	// TODO use the given intersection point instead of recalculating it (still need to calculate the normal)
	dvec4 normal = iteratTo(r, longRadius, shortRadius);

	double x_extent = tor.objectParameters[0][0]; // width
	double z_extent = tor.objectParameters[0][1]; // length
	r.weight = wasteBox(r.position[0], r.position[2], x_extent, z_extent, r.weight);

	// element missed
	if(r.weight < 1.0) {
		// rays that missed an element get weight 2
		r.weight = 2;
		return r;
	}

	// add the travelled distance from the previous position to the new intersection to pathlength (both are in the same coordinate system so we do not need to transform back to world coordinates??)
	r.pathLength += length(old_position - r.position);
	r.lastElement = elementIndex+1;
	
	// tanger/slope Error
	double slopeX = tor.objectParameters[0][2];
	double slopeZ = tor.objectParameters[0][3];
	normal = tanger(normal, slopeX, slopeZ, 0, ctr);
	
	r.direction = dvec3(reflect(dvec4(r.direction,0), normal));
	
	r.order = 0;
	return r;
}

/**
* calculates resulting ray for an RZP
* @param r				ray to trace in element coordinates
* @param elementIndex	index of element in data buffer
* @param ctr			counter for random number generator, always inout
* @param intersection	intersection point in ELEMENT coordinates
*
* output: reflected Ray with intersection point as position, reflection as direction in ELEMENT coordinates and possibly modified weight
*/
Ray traceRZP(Ray r, const int elementIndex, inout uint64_t ctr, dvec4 intersection) {
	Element rzp = quadricData[elementIndex];
	double element_offset_z = rzp.elementParameters[3][2];
	r.position.z = r.position.z - element_offset_z;
	
	// store old position, needed for pathlength calculation
	dvec3 old_position = r.position;
	
	dvec4 normal;
	// RZP can be plane, toroidal or spherical curvature type. Use intersectionPoint for all except toroidal
	int CURVATURE_TYPE = int(rzp.elementParameters[1][0]);
	if (CURVATURE_TYPE != 2) {
		normal = setIntersectionPoint(r, rzp.surfaceParams, intersection);
	} else {
		double longRadius = rzp.surfaceParams[0][0];
		double shortRadius = rzp.surfaceParams[0][1];
		normal = iteratTo(r, longRadius, shortRadius);
	}

	// ! temporary change to test the trapezoid
	double x_extentA = rzp.objectParameters[0][0]; // widthA
	double x_extentB = rzp.objectParameters[2][1]; // widthB for trapezoid
	double z_extent = rzp.objectParameters[0][1]; // height
	double hit  = wasteBox(r.position[0], r.position[2], x_extentA, x_extentB, z_extent, r.weight);


	if(hit < 1.0) {
		r.position.z += element_offset_z;
		// rays that missed an element get weight 2
		r.weight = 2;
		return r;
	}
	
	// add the travelled distance from the previous position to the new intersection to pathlength (both are in the same coordinate system so we do not need to transform back to world coordinates??)
	r.pathLength += length(old_position - r.position);
	r.lastElement = elementIndex+1;
	
	int IMAGE_TYPE = int(rzp.elementParameters[0][0]);
	int RZP_TYPE = int(rzp.elementParameters[0][1]);
	int DERIVATION_METHOD = int(rzp.elementParameters[0][2]);
	double risag = rzp.elementParameters[2][0];
	double rosag = rzp.elementParameters[2][1];
	double rimer = rzp.elementParameters[2][2];
	double romer = rzp.elementParameters[2][3];
	double d_alpha = rzp.elementParameters[3][0];
	double d_beta = rzp.elementParameters[3][1];
	double d_ord = rzp.elementParameters[1][1];
	double zOffsetCenter = rzp.elementParameters[1][3];; // fresnel center z offset
	double WL = hvlam(r.energy);
	double WL0 = 1e-06*rzp.elementParameters[0][3]; // source energy/design energy
	double Ord = rzp.elementParameters[1][2];
	int additional_order = int(rzp.elementParameters[3][3]);

	// calculate the RZP line density for the position of the intersection on the RZP
	double DX, DZ;
	RZPLineDensity(r, normal, IMAGE_TYPE, RZP_TYPE, DERIVATION_METHOD, zOffsetCenter, risag, rosag, rimer, romer, d_alpha, d_beta, d_ord, WL0, DX, DZ);

	// tanger/slope Error
	double slopeX = rzp.objectParameters[0][2];
	double slopeZ = rzp.objectParameters[0][3];
	normal = tanger(normal, slopeX, slopeZ, 0, ctr);

	// if additional zero order should be traced, approx. half of the rays are randomly chosen to be traced in order 0 (= ordinary reflection) instead of the given order
	if(additional_order == 1) {
		if(squaresDoubleRNG(ctr) > 0.5)
			Ord = 0;
	}
	
	// only 2D case, not 2 1D gratings with 90 degree rotation as in old RAY
	double az = WL*DZ*Ord*1e-6;
	double ax = WL*DX*Ord*1e-6;
 	r = refrac2D(r, normal, az, ax);
	r.order = Ord;
	
	r.position.z += element_offset_z;
	return r;
}

/**
* calculates resulting ray for plane grating element
* separate from "generalGratingElement" because normal is always (0,-1,0). Therefore, the refrac function can be simplified such that it does not use trigonom. functions
* @param r				ray to trace in element coordinates
* @param elementIndex	index of element in data buffer
* @param ctr			counter for random number generator, always inout
* @param intersection	intersection point in ELEMENT coordinates
* @return				reflected Ray with intersection point as position, reflection as direction in ELEMENT coordinates and possibly modified weight
*/
Ray tracePlaneGrating(Ray r, const int elementIndex, inout uint64_t ctr, dvec4 intersection) {
	Element plgrt = quadricData[elementIndex];
	
	// store old position, needed for pathlength calculation
	dvec3 old_position = r.position;
	
	// calculate intersection point with element surface and return surface normal at this point
	dvec4 normal = setIntersectionPoint(r, plgrt.surfaceParams, intersection);
	
	// check if element was hit
	double x_extent = plgrt.objectParameters[0][0];
	double z_extent = plgrt.objectParameters[0][1];
	double hit = wasteBox(r.position.x, r.position.z, x_extent, z_extent, r.weight);

	if(hit < 1.0) {
		// rays that missed an element get weight 2
		r.weight = 2;
		return r;
	}
	// modify normal according to slope error
	double slopeX = plgrt.objectParameters[0][2];
	double slopeZ = plgrt.objectParameters[0][3];
	normal = tanger(normal, slopeX, slopeZ, 0, ctr);

	// vls parameters passed in q.elementParameters
	double WL = hvlam(r.energy);
	double lineDensity = plgrt.elementParameters[0][2];
	double orderOfDiffraction = plgrt.elementParameters[0][3];
	double b_params[6] = double[6] (plgrt.elementParameters[1][2], plgrt.elementParameters[1][3], plgrt.elementParameters[2][0], plgrt.elementParameters[2][1], plgrt.elementParameters[2][2], plgrt.elementParameters[2][3]);
	int additional_order = int(plgrt.elementParameters[3][3]);

	// a = WL * linedensity * order * 1e-06
	double a = vlsGrating(lineDensity, r.position.z, b_params) * WL *  orderOfDiffraction * 1e-06;
	r.order = orderOfDiffraction;
	
	// if additional zero order should be traced, approx. half of the rays are randomly chosen to be traced in order 0 (= ordinary reflection) instead of the given order
	if(additional_order == 1) {
		if(squaresDoubleRNG(ctr) > 0.5)
			a = 0;
	}

	// add the travelled distance from the previous position to the new intersection to pathlength (both are in the same coordinate system so we do not need to transform back to world coordinates??)
	r.pathLength += length(old_position - r.position);
	r.lastElement = elementIndex+1;
	
	// calculate refracted ray
	r = refrac_plane(r, normal, a);

	return r;
}

/**
* calculates resulting ray for general grating element
* @param r				ray to trace in element coordinates
* @param elementIndex	index of element in data buffer
* @param ctr			counter for random number generator, always inout
* @param intersection	intersection point in ELEMENT coordinates
* @return reflected Ray with intersection point as position, reflection as direction in ELEMENT coordinates and possibly modified weight
*/
Ray traceGeneralGrating(Ray r, const int elementIndex, inout uint64_t ctr, dvec4 intersection) {
	Element grt = quadricData[elementIndex];
	
	int ISIG = 1;
	double radius = grt.surfaceParams[1][3]; // -radius , a_24
	if(-radius < 0) {
		ISIG = -1;
	}
	
	// store old position, needed for pathlength calculation
	dvec3 old_position = r.position;
	
	dvec4 normal = setIntersectionPoint(r, grt.surfaceParams, intersection);
	//normal = normalize(dvec4(-r.position.x, -radius - r.position[1]*ISIG, -r.position[2], 0));

	// check if element was hit
	double x_extent = grt.objectParameters[0][0];
	double z_extent = grt.objectParameters[0][1];
	double hit = wasteBox(r.position.x, r.position.z, x_extent, z_extent, r.weight);

	// if ray missed the surface, stop the tracing here and return the ray in world coordinates
	if(hit < 1.0) {
		// rays that missed an element get weight 2
		r.weight = 2;
		return r;
	}
	
	// add the travelled distance from the previous position to the new intersection to pathlength (both are in the same coordinate system so we do not need to transform back to world coordinates??)
	r.pathLength += length(old_position - r.position);
	r.lastElement = elementIndex+1;
	
	// modify normal according to slope error
	double slopeX = grt.objectParameters[0][2];
	double slopeZ = grt.objectParameters[0][3];
	normal = tanger(normal, slopeX, slopeZ, 0, ctr);

	// vls parameters passed in q.elementParameters
	double WL = hvlam(r.energy);
	double lineDensity = grt.elementParameters[0][2];
	double orderOfDiffraction = grt.elementParameters[0][3];
	double b_params[6] = double[6] (grt.elementParameters[1][2], grt.elementParameters[1][3], grt.elementParameters[2][0], grt.elementParameters[2][1], grt.elementParameters[2][2], grt.elementParameters[2][3]);
	
	// linedensity = WL * default_linedensity * order * 1e-06
	double linedensity = vlsGrating(lineDensity, r.position.z, b_params) * WL *  orderOfDiffraction * 1e-06;
	r.order = orderOfDiffraction;
	// no additional zero order here?

	// refraction
	r = refrac(r, normal, linedensity);

	return r;
}

/**
* calculates resulting ray for a mirror element
* @param r				ray to trace in element coordinates
* @param elementIndex	index of element in data buffer
* @param ctr			counter for RNG
* @param intersection	intersection point in ELEMENT coordinates
*
* output: reflected Ray with intersection point as position, reflection as direction in ELEMENT coordinates and possibly modified weight
*/
Ray traceMirror(Ray r, const int elementIndex, inout uint64_t ctr, dvec4 intersection) {
	Element mrr = quadricData[elementIndex];
	
	// store old position, needed for pathlength calculation
	dvec3 old_position = r.position;
	
	// calculate intersection point and normal at intersection point
	dvec4 normal = setIntersectionPoint(r, mrr.surfaceParams, intersection);

	// check if ray hit the element within the boundaries
	double x_extent = mrr.objectParameters[0][0]; // width
	double z_extent = mrr.objectParameters[0][1]; // height
	double hit = wasteBox(r.position.x, r.position.z, x_extent, z_extent, r.weight);
	
	// if ray missed the surface, stop the tracing here and return the ray in world coordinates
	if(hit < 1.0) {
		// rays that missed an element get weight 2
		r.weight = 2;
		return r;
	}

	// add the travelled distance from the previous position to the new intersection to pathlength (both are in the same coordinate system so we do not need to transform back to world coordinates??)
	r.pathLength += length(old_position - r.position);
	r.lastElement = elementIndex+1;
	
	// take the slope error into account for the normal
	double slopeX = mrr.objectParameters[0][2];
	double slopeZ = mrr.objectParameters[0][3];
	normal = tanger(normal, slopeX, slopeZ, 0, ctr); // option 0 = default, cartesian normal

	// calculate the new direction after the reflection
	r.direction = dvec3(reflect(dvec4(r.direction,0), normal));
	
	r.order = 0;
	return r;
}


/**
* calculates resulting ray for an ellipsoid mirror element
* @param r				ray to trace in element coordinates
* @param elementIndex	index of element in data buffer
* @param ctr			counter for RNG
* @param intersectionPoint	intersection point in ELEMENT coordinates
*
* @return reflected Ray with intersection point as position, reflection as direction in ELEMENT coordinates and possibly modified weight
*/
Ray traceEllipsoidMirror(Ray r, const int elementIndex, inout uint64_t ctr, dvec4 intersection) {
	Element ell = quadricData[elementIndex];
	
	double sin_tangentAngle = ell.elementParameters[0][0];
	double cos_tangentAngle = ell.elementParameters[0][1];
	int figureOfRotation = int(ell.elementParameters[1][0]);
	
	// store old position, needed for pathlength calculation
	dvec3 old_position = r.position;
	
	// calculate intersection point and normal at intersection point
	dvec4 normal = setIntersectionPoint(r, ell.surfaceParams, intersection);
	double icurv = ell.surfaceParams[1][0];
	/*normal.x = -q.surfaceParams[0][0] * r.position.x * icurv;
	normal.y = -(r.position.y + q.surfaceParams[1][3]) * icurv;
	normal.z = -(q.surfaceParams[2][2] * r.position.z + q.surfaceParams[2][3]) * icurv;
	normal = normalize(normal);*/
	
	// check if ray hit the element within the boundaries
	double x_extent = ell.objectParameters[0][0]; // width
	double z_extent = ell.objectParameters[0][1]; // height
	r = rotationAroundX(r, -sin_tangentAngle, cos_tangentAngle); // change to coordinate system of mirror
	double hit = wasteBox(r.position.x, r.position.z, x_extent, z_extent, r.weight);
	r = rotationAroundX(r, sin_tangentAngle, cos_tangentAngle); // change to coordinate system of curvation
	
	// if ray missed the surface, stop the tracing here and return the ray in world coordinates
	if(hit < 1.0) {
		// rays that missed an element get weight 2
		return r;
	}

	// add the travelled distance from the previous position to the new intersection to pathlength (both are in the same coordinate system so we do not need to transform back to world coordinates??)
	r.pathLength += length(old_position - r.position);
	r.lastElement = elementIndex+1;
	
	// take the slope error into account for the normal
	double slopeX = ell.objectParameters[0][2];
	double slopeZ = ell.objectParameters[0][3];
	normal = tanger(normal, slopeX, slopeZ, 0, ctr); // option 0 = default, cartesian normal

	// calculate the new direction after the reflection
	r.direction = dvec3(reflect(dvec4(r.direction,0), normal));

	r.order = 0;
	return r;
}


/**
* the image plane is always parallel to x-y-plane of ray coordinate system in which the rays are when they leave the previous element
* -> defined by distance to that element
* @param r		ray to trace in element coordinates
* @param elementIndex	index of element in data buffer
* @param intersection	intersection point of ray with optical element in ELMENT coordinates
* @return  reflected Ray with intersection point as position in ELEMENT coordinates
*/
Ray traceImagePlane(Ray r, const int elementIndex, dvec4 intersection) {
	// path length in element coordinates
	r.pathLength += length(r.position - intersection.xyz);
	r.position = intersection.xyz;
	return r;
	/*r = rayMatrixMult(r, q.inTrans);
	dvec3 old_position = r.position;
	double offset = 0 - r.position.z; // length between ray origin (intersection point of previous element) and image plane
	r.position.x = r.position.x + ((r.direction.x / r.direction.z) * offset); // scale x-slope of ray (l/n) by z-length between origin and image plane
	r.position.y = r.position.y + ((r.direction.y / r.direction.z) * offset);
	r.position.z = 0;
	r.weight *= int(r.direction.z > 0); // if ray points away from image plane there is no intersection with it
	r.pathLength += length(r.position - old_position);
	//r = rayMatrixMult(r, q.outTrans);
	return r;*/
}


/*
* iterate through all elements (sequentially) and trace rays element by element
*/
void iterateElements(){
	double type;
	uint numberOfElements = quadricData.length();
	// ray specific "seed" for random numbers -> every ray has a different starting value for the counter that creates the random numbter
	uint64_t workerCounterNum = (~(uint64_t(0)) / uint64_t(numberOfRays));
	uint64_t ctr = uint(gl_GlobalInvocationID) * workerCounterNum;
	
	for(int i=0; i<numberOfElementsPerBeamline; i++){
		Element e = quadricData[i];

		type = int(e.surfaceParams[3][0]);
		dvec4 intersection = getOpticalElementIntersection(rayData[uint(gl_GlobalInvocationID)], i);
		
		if (type == 0) { // mirror
			rayData[uint(gl_GlobalInvocationID)] = traceMirror(rayData[uint(gl_GlobalInvocationID)], i, ctr, intersection);
		}else if(type == 1){ // plane grating
			rayData[uint(gl_GlobalInvocationID)] = tracePlaneGrating(rayData[uint(gl_GlobalInvocationID)], i, ctr, intersection);	
		}else if(type == 2){ // general grating
			rayData[uint(gl_GlobalInvocationID)] = traceGeneralGrating(rayData[uint(gl_GlobalInvocationID)], i, ctr, intersection);	
		}else if(type == 3){ // Slit
			rayData[uint(gl_GlobalInvocationID)] = traceSlit(rayData[uint(gl_GlobalInvocationID)], i, ctr, intersection);	
		}else if(type == 4) { // rzp
			rayData[uint(gl_GlobalInvocationID)] = traceRZP(rayData[uint(gl_GlobalInvocationID)], i, ctr, intersection);	
		}else if(type == 5) { // image plane
			rayData[uint(gl_GlobalInvocationID)] = traceImagePlane(rayData[uint(gl_GlobalInvocationID)], i, intersection);
		}else if(type == 6) { // toroid mirror
			rayData[uint(gl_GlobalInvocationID)] = traceToroid(rayData[uint(gl_GlobalInvocationID)], i, ctr, intersection);	
		}else if(type == 7) { // ellipsoid mirror
			rayData[uint(gl_GlobalInvocationID)] = traceEllipsoidMirror(rayData[uint(gl_GlobalInvocationID)], i, ctr, intersection);	
		}
		//rayData[uint(gl_GlobalInvocationID)] = rayMatrixMult(rayData[uint(gl_GlobalInvocationID)], q.outTrans);
	}
	outputData[uint(gl_GlobalInvocationID)] = rayData[uint(gl_GlobalInvocationID)];
}

// dynamic ray tracing -> check which ray hits which element first
// in this function we need to make sure that rayData ALWAYS remains in GLOBAL coordinates (it can be changed in a function but needs to be changed back before the function returns to this function)
void dynamicElements(){
	const int numberOfElements = quadricData.length();
	//placeholder, info should later be transfered to shader
	const int maxBounces = numberOfElements;
	Ray ray = rayData[uint(gl_GlobalInvocationID)];
	uint beamlineIndex = uint(double(gl_GlobalInvocationID)/numberOfRaysPerBeamLine);
	int whichIntersection = 1;

	// ray specific "seed" for random numbers -> every ray has a different starting value for the counter that creates the random number
	uint64_t workerCounterNum = (~(uint64_t(0)) / int(numberOfRays));
	uint64_t ctr = uint(gl_GlobalInvocationID) * workerCounterNum;
	int type = -1;

	int closestElementIndex = -1;
	int lastClosestElementIndex;
	dvec4 closestHitpoint = dvec4(1.0/0.0, 1.0/0.0, 1.0/0.0, 0.0);
	dvec4 closestGlobalHitpoint;
	double threshold = 0.001;
	
	Element next;
	double bounce = 1;
	//iterate bounces
	for(int i = 0; i<maxBounces; i++){
		ray = rayData[uint(gl_GlobalInvocationID)];

		// last traced element
		lastClosestElementIndex = closestElementIndex;
		// index of element with current closest intersection with ray, initialized with -1
		closestElementIndex = -1;
		// global coordinates of first intersection point of ray among all elements in beamline
		closestHitpoint = dvec4(1.0/0.0, 1.0/0.0, 1.0/0.0, 0);
		closestGlobalHitpoint = dvec4(1.0/0.0, 1.0/0.0, 1.0/0.0, 0);

		//find intersection points with all elements
		for(int elementIndex = int(beamlineIndex)*int(numberOfElementsPerBeamline); elementIndex<(beamlineIndex+1)*numberOfElementsPerBeamline; elementIndex++){
		//for(int elementIndex = 0; elementIndex<numberOfElements; elementIndex++){
			if(elementIndex == lastClosestElementIndex){
				//TODO: self-intersection
				//rayData[uint(gl_GlobalInvocationID)].weight = 11;
				continue;
			}
			//dvec4 currentIntersection = dvec4(1.0/0.0,1.0/0.0,1.0/0.0, 0.0);
			dvec4 currentIntersection = getOpticalElementIntersection(ray, elementIndex);
			
			// intersection coordinates in global coordinates 
			dvec4 currentGlobalIntersection;
			currentGlobalIntersection.xyz = dvec3(quadricData[elementIndex].outTrans *  dvec4(currentIntersection.xyz,1));
			// check if current intersection is closer than the closest previous Hitpoint
			if(length(ray.position - closestGlobalHitpoint.xyz) > length(ray.position-currentGlobalIntersection.xyz) && currentIntersection.w != 0){
				closestHitpoint = currentIntersection;
				closestGlobalHitpoint = currentGlobalIntersection;
				closestElementIndex = elementIndex;
			}
		}
		
		if(closestElementIndex == -1){ // no element was hit
			break;
		}

		// transform ray and intersection point in ELEMENT coordiantes
		next = quadricData[closestElementIndex];
		rayData[uint(gl_GlobalInvocationID)] = rayMatrixMult(rayData[uint(gl_GlobalInvocationID)], next.inTrans);
	
		// calculate interaction of ray with detected next element 
		type = int(next.surfaceParams[3][0]);
		if (type == 0) { // plane + sphere mirror
			rayData[uint(gl_GlobalInvocationID)] = traceMirror(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint); // intersection in ELEMENT coordinates
		}else if(type == 1){ // plane grating
			rayData[uint(gl_GlobalInvocationID)] = tracePlaneGrating(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);	
		}else if(type == 2){ // general grating
			rayData[uint(gl_GlobalInvocationID)] = traceGeneralGrating(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);	
		}else if(type == 3){ // Slit
			rayData[uint(gl_GlobalInvocationID)] = traceSlit(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);	
		}else if(type == 4) { // rzp
			rayData[uint(gl_GlobalInvocationID)] = traceRZP(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);	
		}else if(type == 5) { // image plane
			rayData[uint(gl_GlobalInvocationID)].extraParameter += (closestElementIndex+1) * bounce;
			rayData[uint(gl_GlobalInvocationID)].lastElement = closestElementIndex+1;
			outputData[uint(gl_GlobalInvocationID)] = traceImagePlane(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, closestHitpoint);
			return;
		}else if(type == 6) { // toroid mirror
			rayData[uint(gl_GlobalInvocationID)] = traceToroid(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);
		}else if(type == 7) { // ellipsoid mirror
			rayData[uint(gl_GlobalInvocationID)] = traceEllipsoidMirror(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);	
		}
		// use extraParameter to store the order in which the ray has hit which optical element (e.g extraParameter = 412 -> first hit element 2, then 1, then 4)
		rayData[uint(gl_GlobalInvocationID)].extraParameter += ((closestElementIndex+1) * bounce) * int(rayData[uint(gl_GlobalInvocationID)].lastElement == closestElementIndex+1);
		bounce *= pow(10, int(rayData[uint(gl_GlobalInvocationID)].lastElement == closestElementIndex+1));
		// transform back to world coordinates
		rayData[uint(gl_GlobalInvocationID)] = rayMatrixMult(rayData[uint(gl_GlobalInvocationID)], next.outTrans);
	
	}
	// end the tracing in element coordinates (makes comparison with old RAY easier)
	//rayData[uint(gl_GlobalInvocationID)] = rayMatrixMult(rayData[uint(gl_GlobalInvocationID)], next.inTrans); 
	outputData[uint(gl_GlobalInvocationID)] = rayData[uint(gl_GlobalInvocationID)];
}


void testFunctions() {
	// flag to decide how to interpret the input
	int settings = int(quadricData[0].surfaceParams[3][1]);

	// use dynamic tracing for the given beamline (no unit test)
	if(settings==0) {
		dynamicElements();
		return;
	}
	 
	// ray specific "seed" for random numbers -> every ray has a different starting value for the counter that creates the random numbter
	uint64_t workerCounterNum = (~(uint64_t(0)) / uint64_t(numberOfRays));
	uint64_t ctr = uint(gl_GlobalInvocationID) * workerCounterNum;
	
	Ray r = rayData[uint(gl_GlobalInvocationID)];
	Ray res; // store the result here
	
	// settings != 0 -> unit test cases in test_shader.cpp
	// input rays and elements are interpreted depending on the test case
	if(settings == 1) { // TEST TRIG FUNCTIONS
		res.position = dvec3(r8_cos(r.position.x), r8_cos(r.position.y),r8_sin(r.position.z));
		res.weight = r8_sin(r.weight);
		res.direction = dvec3(r8_atan(r.direction.x), r8_atan(r.direction.y), r8_acos(r.direction.z));
		res.energy = r8_acos(r.energy);
		res.stokes = dvec4(r8_asin(r.stokes[0]), r8_asin(r.stokes[1]), r8_atan(r.stokes[2]), r8_atan(r.stokes[3]));
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 2) { // test refrac
		res = refrac(r, dvec4(r.position, 0), r.weight); // need quadric buffer to put calculated parameter to shader
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 3) { // test plane refrac
		Ray r = rayData[uint(gl_GlobalInvocationID)];
		Ray res;
		// refrac_plane(ray, normal, a) only y and z direction of ray are needed
		// a encoded in weight, normal encoded in r.position
		res = refrac_plane(r, dvec4(r.position, 0), r.weight);
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 4) { // test vls grating
		double b_params[6] = double[6] (r.position.x,r.position.y,r.position.z, r.direction.x,r.direction.y,r.direction.z);//(0.1,0.1,0.1,0.01,0.02,0.03);
		double z = r.energy;
		double a = r.weight;
		res.weight = vlsGrating(a, z, b_params);
		res.pathLength = 0;
		res.extraParameter = 0;
		res.order = 0;
		res.lastElement = 0;
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 5) { // diffraction
		// double bessel1(double v)
		// void bessel_diff(double radius, double wl, inout double dphi, inout double dpsi)
		// void diffraction(int iopt, double xLength, double yLength, double wl, inout double dPhi, inout double dPsi)
		// void fraun_diff(double dim, double wl, inout double dAngle)
		double dPhi;
		double dPsi;
		int iopt = int(r.position.x);
		double xLength = r.position.y;
		double yLength = r.position.z;
		double wl = r.weight;
		diffraction(iopt, xLength, yLength, wl, dPhi, dPsi, ctr);
		res.position.x = dPhi;
		res.position.y = dPsi;
		res.weight = 100;
		res.energy = 0;
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 6) { // bessel1 function
		res.position = dvec3(bessel1(r.position.x),bessel1(r.position.y),bessel1(r.position.z));
		res.direction = dvec3(bessel1(r.direction.x),bessel1(r.direction.y),bessel1(r.direction.z));
		res.weight = bessel1(r.weight);
		res.stokes = dvec4(0,0,0,0);
		res.energy = 0;
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 7) { // double pow test
		res.position.x = dpow(r.position.x, int(r.direction.x));
		res.position.y = dpow(r.position.y, int(r.direction.y));
		res.position.z = dpow(r.position.z, int(r.direction.z));
		res.direction = dvec3(0,0,0);
		res.stokes = dvec4(0,0,0,0);
		res.weight = 0;
		res.energy = 0;
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 8) { // factorial f(a) = a! test
		res.position = dvec3(fact(int(r.position.x)), fact(int(r.position.y)), fact(int(r.position.z)));
		res.direction = dvec3(fact(int(r.direction.x)), fact(int(r.direction.y)), fact(int(r.direction.z)));
		res.weight = fact(int(r.weight));
		res.stokes = dvec4(fact(int(r.stokes.x)), fact(int(r.stokes.y)), fact(int(r.stokes.z)), fact(int(r.stokes[3])));
		res.energy = fact(int(r.energy));
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 9) { // cosini (direction x,y,z from phi,psi)
		res = r;
		cosini(res, r.position.x, r.position.y); // inout ray (only direction important for function), phi, psi
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 10) { // test RayMatrixMult
		res = rayMatrixMult(r, quadricData[0].inTrans);
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 11) { // wastebox
		double x = r.position.x;
		double z = r.position.z;
		double x_extent = r.direction.x;
		double z_extent = r.direction.z;
		double w = r.weight;
		res = r;
		res.weight = wasteBox(x, z, x_extent, z_extent, w);
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 12) { // test RZP line density
		dvec4 normal = dvec4(r.direction.x, r.direction.y, r.direction.z, 0);
		int image_type = int(quadricData[0].inTrans[0][0]);
		int rzp_type =  int(quadricData[0].inTrans[0][1]);
		int derivation_method = int(quadricData[0].inTrans[0][2]);
		double zOffsetCenter = quadricData[0].inTrans[0][3];
		double risag = quadricData[0].inTrans[1][0];
		double rosag = quadricData[0].inTrans[1][1];
		double rimer = quadricData[0].inTrans[1][2];
		double romer = quadricData[0].inTrans[1][3];
		double d_alpha = quadricData[0].inTrans[2][0];
		double d_beta = quadricData[0].inTrans[2][1];
		double d_ord = quadricData[0].inTrans[2][2];
		double wl = quadricData[0].inTrans[2][3];
		double DX;
		double DZ;
		RZPLineDensity(r, normal, image_type, rzp_type, derivation_method, zOffsetCenter,
			risag, rosag, rimer, romer, d_alpha, d_beta, d_ord, wl,
			DX, DZ);
		// write result to r.position to bring it back to the c++ unit test
		res.position.x = DX;
		res.position.z = DZ;
		res.position.y = 0;
		res.direction = dvec3(0,0,0);
		res.stokes = dvec4(0,0,0,0);
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 13) {
		dvec4 normal = dvec4(r.direction,0);
		double slopeX = r.position.x;
		double slopeZ = r.position.z;
		dvec4 new_normal = normal_cartesian(normal, slopeX, slopeZ);
		// normal is in homogeneous coordinates but ray direction and position are only interpreted as dvec3 -> store fourth value in weight
		res.direction = dvec3(new_normal);
		res.weight = new_normal[3];
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 14) {
		dvec4 normal = dvec4(r.direction,0);
		double slopeX = r.position.x;
		double slopeZ = r.position.z;
		dvec4 new_normal = normal_cylindrical(normal, slopeX, slopeZ);
		// normal is in homogeneous coordinates but ray direction and position are only interpreted as dvec3 on C++ side -> store fourth value in weight
		res.direction = dvec3(new_normal);
		res.weight = new_normal[3];
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 15) {
		dvec4 normal = dvec4(r.position, 0);
		double a = quadricData[0].inTrans[0][0];
		// only uses and  modifies ray.direction and weight -> use ray.position to transfer normal
		res = refrac(r, normal, a);
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 16) {
		// Ray refrac2D(Ray r, dvec4 normal, double az, double ax)
		// refrac2D changes only the direction of the ray -> encode normal at intersection point in ray position
		dvec4 normal = dvec4(r.position, 0);
		double az = quadricData[uint(gl_GlobalInvocationID)].inTrans[0][0];
		double ax = quadricData[uint(gl_GlobalInvocationID)].inTrans[0][1];
		res = refrac2D(r, normal, az, ax);
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 17) { // test uniform distribution
		res.weight = double(squares64RNG(ctr)) / double(uint64_t(0) - 1);
		res.energy = double(squares64RNG(ctr)) / double(uint64_t(0) - 1);
		res.position = dvec3(squaresDoubleRNG(ctr), squaresDoubleRNG(ctr),squaresDoubleRNG(ctr));
		res.direction = dvec3(squaresDoubleRNG(ctr), squaresDoubleRNG(ctr), squaresDoubleRNG(ctr));
		res.stokes = dvec4(squaresDoubleRNG(ctr), squaresDoubleRNG(ctr), squaresDoubleRNG(ctr), squaresDoubleRNG(ctr));
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 18) { // test exponential function
		res.weight = r8_exp(r.weight);
		res.energy = r8_exp(r.energy);
		res.position = dvec3(r8_exp(r.position.x), r8_exp(r.position.y), r8_exp(r.position.z));
		res.direction = dvec3(r8_exp(r.direction.x), r8_exp(r.direction.y), r8_exp(r.direction.z));
		res.stokes = dvec4(r8_exp(r.stokes.x), r8_exp(r.stokes.y), r8_exp(r.stokes.z), r8_exp(r.stokes[3]));
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 19) { // test logarithm function (natural logarithm)
		res.weight = r8_log(r.weight);
		res.energy = r8_log(r.energy);
		res.position = dvec3(r8_log(r.position.x), r8_log(r.position.y), r8_log(r.position.z));
		res.direction = dvec3(r8_log(r.direction.x), r8_log(r.direction.y), r8_log(r.direction.z));
		res.stokes = dvec4(r8_log(r.stokes.x), r8_log(r.stokes.y), r8_log(r.stokes.z), r8_log(r.stokes[3]));
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 20) { // test iteratTo (method for finding intersection and normal for non-quadric surfaces like the torus)
		dvec4 normal = iteratTo(r, quadricData[0].surfaceParams[0][0], quadricData[0].surfaceParams[0][1]);
		rayData[uint(gl_GlobalInvocationID)] = r;
	}else if(settings == 21) { // test getTheta function that is needed for the efficiency calculations
		Ray res;
		res.weight = getTheta(r, dvec4(r.position,0));
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	// store results to output buffer
	outputData[uint(gl_GlobalInvocationID)] = rayData[uint(gl_GlobalInvocationID)];
}

void main(){
    //dynamicElements();
	testFunctions();
	
	// output = input:
    //outputData[uint(gl_GlobalInvocationID)] = rayData[uint(gl_GlobalInvocationID)];
}
